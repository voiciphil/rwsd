# 입출금 내역 분석기

## 프로그램 요구 사항
* 거래 내역 파일을 읽어 전체 수입과 지출의 합계를 구해라.
* 거래 내역 파일을 읽어 특정 달의 수입과 지출의 합계를 구해라.

## 1. main 메서드에 기능을 모두 구현

BankStatementAnalyzer 클래스에 main 메서드를 생성하고 다음 기능을 구현한다.  
* 거래 내역 csv 파일을 읽어 한 줄씩 파싱하고 전체 수입과 지출의 합계를 구해 출력한다.
* 다시 한 줄씩 파싱하여 1월의 수입과 지출의 합계를 구해 출력한다.

### 문제점
#### God Class Anti-Pattern (한 클래스로 모든 것을 해결하려는 패턴)
* BankStatementAnalyzer 라는 거대한 클래스가 생성되면서 클래스의 목적을 이해하기 어렵다.
* 특정 로직을 갱신해야 한다면 찾아서 고치기 매우 힘들다.

#### 코드의 중복
* 현재 한 가지 상황(컴마로 구분된 csv 파일)만 처리할 수 있게 설계되었고 중복이 많아 기능을 확장, 수정하기 어렵다.

## 2. 단일 책임 원칙(SRP)을 적용하여 리팩토링

파일을 파싱하는 부분을 추출해 BankStatementCsvParser 클래스로 만든다.

### 기대 효과
* 새로운 요구 사항이 들어왔을 때 기능을 재사용할 수 있다.
* 파싱 알고리즘을 개선해야 할 때 한 곳의 코드만 바꾸면 된다.
* 응집도가 높아진다.

### SRP(Single Responsibility Principle)
* 한 클래스는 한 기능만 책임진다.
* 한 클래스가 변경되어야 하는 이유는 오직 하나여야 한다.

## 3. 응집도를 높이기 위한 리팩토링

BankStatementAnalyzer 클래스에 전체 수입과 지출의 총합, 월별 수입과 지출의 총합을 
계산하는 코드가 포함되어 있어서 응집도가 떨어진다. 이 부분을 새로운 클래스의 메서드로 만든다.

### 기대 효과
* 계산과 관련된 로직을 한 클래스에 모아 응집도가 높아진다.
* BankStatementAnalyzer 클래스를 의존하지 않고도 계산하는 로직을 재사용할 수 있다.

### 응집도
* 클래스나 메서드의 책임이 서로 얼마나 강하게 연결되어 있는지를 나타낸다.
* 응집도가 높을 수록 유지보수하기 쉽다.

## 4. 결합도를 낮추기 위한 리팩토링

BankStatementAnalyzer 클래스는 BankStatementCsvParser 클래스에 의존하고 있다.
JSON, XML 형식의 파일이 들어와도 유연하게 대처할 수 있도록 interface를 이용해 두 클래스의 결합을 제거한다.

### 기대 효과
* 클래스 간 결합도가 낮아져 한 클래스에 문제가 생기더라도 다른 클래스에 미치는 영향이 적다.

### 결합도
* 한 기능이 다른 기능에 얼마나 의존하고 있는지를 나타낸다.
어떤 클래스를 구현하는 데 얼마나 많이 다른 클래스를 참조하는가로 설명할 수 있다.
* 결합도가 낮을 수록 기능을 변경할 때 유연성이 높아진다.

