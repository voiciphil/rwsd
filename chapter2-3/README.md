# 입출금 내역 분석기

## 프로그램 요구 사항
* 거래 내역 파일을 읽어 전체 수입과 지출의 합계를 구하여야 한다.
* 거래 내역 파일을 읽어 특정 달의 수입과 지출의 합계를 구하여야 한다.

### 1. main 메서드에 기능을 모두 구현

BankStatementAnalyzer 클래스에 main 메서드를 생성하고 다음 기능을 구현한다.  
* 거래 내역 csv 파일을 읽어 한 줄씩 파싱하고 전체 수입과 지출의 합계를 구해 출력한다.
* 다시 한 줄씩 파싱하여 1월의 수입과 지출의 합계를 구해 출력한다.

#### 문제점
##### God Class Anti-Pattern (한 클래스로 모든 것을 해결하려는 패턴)
* BankStatementAnalyzer 라는 거대한 클래스가 생성되면서 클래스의 목적을 이해하기 어렵다.
* 특정 로직을 갱신해야 한다면 찾아서 고치기 매우 힘들다.

##### 코드의 중복
* 현재 한 가지 상황(컴마로 구분된 csv 파일)만 처리할 수 있게 설계되었고 중복이 많아 기능을 확장, 수정하기 어렵다.

### 2. 단일 책임 원칙(SRP)을 적용하여 리팩토링

파일을 파싱하는 부분을 추출해 BankStatementCsvParser 클래스로 만든다.

#### 기대 효과
* 새로운 요구 사항이 들어왔을 때 기능을 재사용할 수 있다.
* 파싱 알고리즘을 개선해야 할 때 한 곳의 코드만 바꾸면 된다.
* 응집도가 높아진다.

#### SRP(Single Responsibility Principle)
* 한 클래스는 한 기능만 책임진다.
* 한 클래스가 변경되어야 하는 이유는 오직 하나여야 한다.

### 3. 응집도를 높이기 위한 리팩토링

BankStatementAnalyzer 클래스에 전체 수입과 지출의 총합, 월별 수입과 지출의 총합을 
계산하는 코드가 포함되어 있어서 응집도가 떨어진다. 이 부분을 새로운 클래스의 메서드로 만든다.

#### 기대 효과
* 계산과 관련된 로직을 한 클래스에 모아 응집도가 높아진다.
* BankStatementAnalyzer 클래스를 의존하지 않고도 계산하는 로직을 재사용할 수 있다.

#### 응집도
* 클래스나 메서드의 책임이 서로 얼마나 강하게 연결되어 있는지를 나타낸다.
* 응집도가 높을 수록 유지보수하기 쉽다.

### 4. 결합도를 낮추기 위한 리팩토링

BankStatementAnalyzer 클래스는 BankStatementCsvParser 클래스에 의존하고 있다.
JSON, XML 형식의 파일이 들어와도 유연하게 대처할 수 있도록 interface를 이용해 두 클래스의 결합을 제거한다.

#### 기대 효과
* 클래스 간 결합도가 낮아져 한 클래스에 문제가 생기더라도 다른 클래스에 미치는 영향이 적다.

#### 결합도
* 한 기능이 다른 기능에 얼마나 의존하고 있는지를 나타낸다.
어떤 클래스를 구현하는 데 얼마나 많이 다른 클래스를 참조하는가로 설명할 수 있다.
* 결합도가 낮을 수록 기능을 변경할 때 유연성이 높아진다.

## 새로운 요구 사항
* 특정 조건에 맞는 입출금 내역을 검색할 수 있어야 한다.

### 1. 한 클래스에 모든 메서드 추가
특정 가격 이상의 거래 내역을 검색하는 메서드, 특정 달의 거래 내역을 검색하는 메서드,
특정 달에 특정 가격 이상의 거래 내역을 검색하는 메서드를 BankStatementProcessor 클래스에 모두 구현한다.

#### 문제점
* 거래 내역의 여러 속성을 조합할수록 코드가 복잡해진다.
* 반복 로직과 비즈니스 로직이 결합되어 분리하기가 어렵다.
* 조건 부분만 다르고 반복 로직은 전부 같으므로 코드가 중복된다.

### 2. 개방 폐쇄 원칙(OCP)를 적용하여 리팩토링
BankTransaction 객체가 특정한 조건을 만족하는지를 알려주는 test 메서드를 interface에 추가한다.
원하는 조건을 구현한 람다 표현식을 매개변수로 넘겨서 결과를 반환하도록 한다.

#### 기대 효과
* 반복 로직과 비즈니스 로직이 분리가 되었다.
* 새로운 조건이 추가되어도 새 메서드를 만들 필요가 없다.
* 중복된 코드를 하나로 만들어서 수정에 용이하다.

#### OCP(Open-Closed Principle)
* 소프트웨어 개체(클래스, 메서드 등)는 확장에 대해 열려있고, 수정에 대해 닫혀있어야 한다.
* 특정 기능을 변경하거나 추가할 때 다른 요소에 연쇄적으로 영향을 미치는 일이 적어야 한다. 
